# 📘 Gröbner Basis 自动解多项式脚本 · 使用说明

> 适用场景：
>  **CTF 密码题 / 数学题 / RSA 变形题** 中，
>  已知若干 **模 n 的多项式同余方程**，
>  想用 **GB（Gröbner Basis）消元** 解出某个变量（如 `x = m² mod n`）。

------

## 一、这个脚本是干什么的？（一句话版）

👉 **自动用 Gröbner Basis 消掉多余变量，只留下你想要的变量，然后把线性情况直接解出来。**

比如你这道题，本质是：

```
已知：
F1(x,a)^3 ≡ c1 (mod n)
F2(x,a)^3 ≡ c2 (mod n)
F3(x,a)^3 ≡ c3 (mod n)

目标：
解出 x ≡ m^2 (mod n)
```

这个脚本会自动帮你完成：

1. 建多项式环（mod n）
2. 算 Gröbner Basis
3. 消掉 `a`，留下 `x`
4. 如果是线性：直接解
5. 输出 `x (mod n)` 以及整数 lift

------

## 二、你什么时候该用这个脚本？

### ✅ 非常适合用的情况

- 有 **2 个及以上多项式方程**
- 方程里有 **多个变量**
- 方程是 **模 n 的**
- 指数不算特别小（普通解不出来）
- 感觉“出题人是想让你消元的”

**典型关键词**：

- `m^2`、`m^3`
- `a` 是随机辅助变量
- `^e mod n`
- 多个密文、同一个 `n`

------

### ❌ 不适合的情况

- 只有一个方程
- 完全线性的普通方程
- 变量太多（>4 个，GB 会爆）
- n 特别大、次数特别高（GB 算不动）

------

## 三、环境要求（一定要看）

### ✅ 必须使用 Sage

❌ 不能用纯 Python
 ❌ 不能用普通 Jupyter Python 内核

### 正确方式之一：

```
sage -python your_script.py
```

或在 Sage 交互环境 / Sage Notebook 里运行。

------

## 四、脚本结构总览（你只需要改 3 个地方）

### ① 填模数和密文（最简单）

```
n = Integer(...)
c1 = Integer(...)
c2 = Integer(...)
c3 = Integer(...)
```

直接把题目给的复制进去。

------

### ② 声明变量名（**非常重要**）

```
vars_all = ['a', 'x']
target = 'x'
```

含义是：

- `vars_all`：**所有变量的名字**
- `target`：**你最终想解的变量**

📌 规则：

- 想消掉的变量写前面
- 想留下的变量写 `target`

#### 举例：

| 题目变量     | 写法            |
| ------------ | --------------- |
| 解 x，消 a   | `['a','x']`     |
| 解 m，消 a   | `['a','m']`     |
| 解 x，消 a,b | `['a','b','x']` |

------

### ③ 写出方程（核心）

你只需要改这个函数：

```
def build_equations(R, gens):
    a = gens['a']
    x = gens['x']

    F1 = (x - 13*a)**7 - 1337
    F2 = (x + 37*a)**5 + 7331
    F3 = (x - 1337)**137 + 7331

    eqs = [
        F1**3 - c1,
        F2**3 - c2,
        F3**3 - c3,
    ]
    return eqs
```

### 写方程的原则：

- **左边写成多项式**

- **表示 poly ≡ 0 (mod n)**

- 所以要写成：

	```
	原表达式 - 密文
	```

------

## 五、脚本运行后你会看到什么？

### 正常输出示例：

```
[*] vars order: ['a', 'x']
    [+] found Px: x + 13727229...
    [+] degree: 1
    root = 37618894...
    lift = 37618894...
[✓] SUCCESS
```

### 这些信息是什么意思？

- `found Px: x + C`
	 👉 表示 `x ≡ -C (mod n)`
- `degree: 1`
	 👉 线性，直接解
- `root`
	 👉 `x (mod n)`
- `lift`
	 👉 把它当整数 `0 ≤ x < n`

------

## 六、接下来你该干什么？（常见后处理）

### 如果你解的是 `x = m^2 mod n`

接下来通常是：

```
import gmpy2
from Crypto.Util.number import long_to_bytes

x0 = Integer(lift(root))

for k in range(1 << 20):
    t = x0 + k*n
    s = gmpy2.isqrt(t)
    if s*s == t:
        print(long_to_bytes(int(s)))
        break
```

------

## 七、脚本内部做了哪些“聪明的事”？（给进阶用）

你这份脚本**已经不是玩具**了，它会：

- ✅ 自动尝试变量顺序（不用你手调）
- ✅ 自动区分一元 / 多元线性
- ✅ 一元线性：`u*x+v` 直接解
- ✅ 多元线性：`u*x+h(a)` 也能解
- ✅ 如果 `u` 不可逆，尝试 `gcd(u,n)`（可能直接分解 n）

------

## 八、最常见错误 & 怎么解决

### ❌ 报错：`roots() failed`

👉 正常，合数模下经常这样
 👉 脚本已优先用“线性直接解”

------

### ❌ GB 算很久 / 卡死

👉 方程次数太高 / 变量太多
 👉 尝试：

- 减少方程
- 先手动降幂（比如设 `x=m^2`）
- 只留最关键的 2~3 个方程

------

### ❌ 显示 `no univariate poly found`

👉 说明当前顺序没消出来
 👉 你可以：

- 增加一个方程
- 检查方程是否真的相关
- 手动指定顺序（固定 vars_all）

------

## 九、一句话总结（你可以记住这个）

> **这个脚本 = GB 消元自动化工具**
>
> - 能用就用
> - 能消到线性就稳赢
> - 解不出来通常不是你代码错，是题目结构不适合 GB





## 十、判断清单

## 1）先看题面结构：有没有“消元味”

✅ 满足任意 2 条，就很像要你用消元（GB/Resultant/消参）：

- **同一 n、多条密文/等式**（≥2 条）
- **同一未知量 m/x，配一个随机 a/r/t**（“辅助变量”）
- 方程形式像：`(线性组合)^e ≡ c (mod n)`、`(m + k·a)^e`、`(a·m + b)^e`
- 明确出现 **m² / m³ / x=m²** 这种“中间变量”
- 题目强调“同模数、不同偏移、同指数 e”

❌ 反过来：只有一个同余、没有辅助变量、没有重复结构 → GB 往往不划算。

------

## 2）未知数数量：2～3 个是甜点区

**强推荐 GB：**

- 未知数 **2 个**（例如 `a, x` / `a, m`）
- 未知数 **3 个**也可以（例如 `a, b, x`），但要更谨慎

**不推荐/很危险：**

- 未知数 **≥4 个**：除非次数非常低、方程很多、结构特别规整，否则容易爆炸。

------

## 3）次数与指数：看“展开后总次数”而不是 e 本身

快速经验值（非常好用）：

- ✅ **总次数 ≤ 6**：基本可跑
- ⚠️ **总次数 7～10**：看变量数、方程数、是否稀疏
- ❌ **总次数 > 10**：大概率卡死（除非你能先换元降次）

> 例：`(x + 13a)^3` 展开总次数 3；
>  `((x + 13a)^3 - c)` 总次数仍 3；
>  但如果你写成 `F^7 - c` 那就直接 7 了。

------

## 4）方程数量：至少要“比未知数多 0～1 条”

粗略判断：

- 未知数 2 个：方程 **2～3 条**最佳
- 未知数 3 个：方程 **3～4 条**才稳

只有 “刚好等于未知数条数” 有时也行，但更依赖结构（是否独立）。

------

## 5）是否能“换元降维/降次”：能换就更适合 GB

你看到以下情况，**先换元再 GB** 成功率暴增：

- 题目要的是 `m`，但方程里只有 `m²` → 设 `x = m²`
- 出现 `m^e`，但你能把 `(…)^e ≡ c` 改写成多个多项式条件（比如已知 e 很小、或有多条同底）
- 方程里有重复子表达式：设中间变量减少复杂度

------

## 6）模数 n 的性质：合数模 OK，但要注意“不可逆系数”

GB 在 `Z/nZ` 上能跑，但你要观察：

- ✅ 系数经常是小整数（k、偏移量）
- ⚠️ 如果消出来的一元线性是 `u*x + v ≡ 0 (mod n)`
	- **gcd(u, n) = 1**：直接解，稳赢
	- **gcd(u, n) > 1**：反而可能直接 **把 n 分解了**（这也是好事）
- ❌ 如果经常出现大量系数与 n 共享因子、导致“不可逆”且没有新信息 → 容易卡在一堆解集上

------

## 7）“你能期待消到什么”：优先期待一元线性/低次一元

上 GB 前你要心里有预期：

**最理想（秒解）：**

- 消完后出现 `Px(x) = u*x + v`（一次）

**还能接受：**

- `Px(x)` 二次/三次，且你能进一步枚举/开方/小根

**危险信号：**

- 消完只得到高次一元（≥8）且模数是大合数 → roots 很难，后处理也痛苦

------

## 8）最快的“开跑前自检”：稀疏度 & 共享结构

这条是经验大杀器：

- ✅ 多项式 **很稀疏**（项少），GB 更容易
- ✅ 多条方程之间共享很多结构（同一套 `(x ± k·a)^e`），更容易消
- ❌ 每条方程都长得完全不一样、项爆炸 → GB 不香

------

## 9）什么时候别硬上 GB：直接换别的套路更快

出现以下任意一种，通常优先考虑非 GB：

- e 很小（2/3/5）且你能构造 **差分/消 a** 的代数消去（手工消参、resultant）
- 明显是 **小根/近似/泄露**（Coppersmith、HNP、LLL）那类
- 结构像线性方程组（直接解就行）
- 变量很多但每个只出现一次（更像解联立而不是 GB）

------

## 10）一句话决策法（强烈建议你记这个）

只要你看到：

> **同 n + 多条同余 + 2~3 个变量 + (线性组合)^e 这种重复结构 + 你只想留一个变量**

那就 **优先上 GB**。
 并且先把目标变量换成 `x=m²` 这种“降次替身”，成功率更高。