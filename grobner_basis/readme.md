# 📘 Gröbner Basis 自动解多项式脚本 · 使用说明

> 适用场景：
>  **CTF 密码题 / 数学题 / RSA 变形题** 中，
>  已知若干 **模 n 的多项式同余方程**，
>  想用 **GB（Gröbner Basis）消元** 解出某个变量（如 `x = m² mod n`）。

------

## 一、这个脚本是干什么的？（一句话版）

👉 **自动用 Gröbner Basis 消掉多余变量，只留下你想要的变量，然后把线性情况直接解出来。**

比如你这道题，本质是：

```
已知：
F1(x,a)^3 ≡ c1 (mod n)
F2(x,a)^3 ≡ c2 (mod n)
F3(x,a)^3 ≡ c3 (mod n)

目标：
解出 x ≡ m^2 (mod n)
```

这个脚本会自动帮你完成：

1. 建多项式环（mod n）
2. 算 Gröbner Basis
3. 消掉 `a`，留下 `x`
4. 如果是线性：直接解
5. 输出 `x (mod n)` 以及整数 lift

------

## 二、你什么时候该用这个脚本？

### ✅ 非常适合用的情况

- 有 **2 个及以上多项式方程**
- 方程里有 **多个变量**
- 方程是 **模 n 的**
- 指数不算特别小（普通解不出来）
- 感觉“出题人是想让你消元的”

**典型关键词**：

- `m^2`、`m^3`
- `a` 是随机辅助变量
- `^e mod n`
- 多个密文、同一个 `n`

------

### ❌ 不适合的情况

- 只有一个方程
- 完全线性的普通方程
- 变量太多（>4 个，GB 会爆）
- n 特别大、次数特别高（GB 算不动）

------

## 三、环境要求（一定要看）

### ✅ 必须使用 Sage

❌ 不能用纯 Python
 ❌ 不能用普通 Jupyter Python 内核

### 正确方式之一：

```
sage -python your_script.py
```

或在 Sage 交互环境 / Sage Notebook 里运行。

------

## 四、脚本结构总览（你只需要改 3 个地方）

### ① 填模数和密文（最简单）

```
n = Integer(...)
c1 = Integer(...)
c2 = Integer(...)
c3 = Integer(...)
```

直接把题目给的复制进去。

------

### ② 声明变量名（**非常重要**）

```
vars_all = ['a', 'x']
target = 'x'
```

含义是：

- `vars_all`：**所有变量的名字**
- `target`：**你最终想解的变量**

📌 规则：

- 想消掉的变量写前面
- 想留下的变量写 `target`

#### 举例：

| 题目变量     | 写法            |
| ------------ | --------------- |
| 解 x，消 a   | `['a','x']`     |
| 解 m，消 a   | `['a','m']`     |
| 解 x，消 a,b | `['a','b','x']` |

------

### ③ 写出方程（核心）

你只需要改这个函数：

```
def build_equations(R, gens):
    a = gens['a']
    x = gens['x']

    F1 = (x - 13*a)**7 - 1337
    F2 = (x + 37*a)**5 + 7331
    F3 = (x - 1337)**137 + 7331

    eqs = [
        F1**3 - c1,
        F2**3 - c2,
        F3**3 - c3,
    ]
    return eqs
```

### 写方程的原则：

- **左边写成多项式**

- **表示 poly ≡ 0 (mod n)**

- 所以要写成：

	```
	原表达式 - 密文
	```

------

## 五、脚本运行后你会看到什么？

### 正常输出示例：

```
[*] vars order: ['a', 'x']
    [+] found Px: x + 13727229...
    [+] degree: 1
    root = 37618894...
    lift = 37618894...
[✓] SUCCESS
```

### 这些信息是什么意思？

- `found Px: x + C`
	 👉 表示 `x ≡ -C (mod n)`
- `degree: 1`
	 👉 线性，直接解
- `root`
	 👉 `x (mod n)`
- `lift`
	 👉 把它当整数 `0 ≤ x < n`

------

## 六、接下来你该干什么？（常见后处理）

### 如果你解的是 `x = m^2 mod n`

接下来通常是：

```
import gmpy2
from Crypto.Util.number import long_to_bytes

x0 = Integer(lift(root))

for k in range(1 << 20):
    t = x0 + k*n
    s = gmpy2.isqrt(t)
    if s*s == t:
        print(long_to_bytes(int(s)))
        break
```

------

## 七、脚本内部做了哪些“聪明的事”？（给进阶用）

你这份脚本**已经不是玩具**了，它会：

- ✅ 自动尝试变量顺序（不用你手调）
- ✅ 自动区分一元 / 多元线性
- ✅ 一元线性：`u*x+v` 直接解
- ✅ 多元线性：`u*x+h(a)` 也能解
- ✅ 如果 `u` 不可逆，尝试 `gcd(u,n)`（可能直接分解 n）

------

## 八、最常见错误 & 怎么解决

### ❌ 报错：`roots() failed`

👉 正常，合数模下经常这样
 👉 脚本已优先用“线性直接解”

------

### ❌ GB 算很久 / 卡死

👉 方程次数太高 / 变量太多
 👉 尝试：

- 减少方程
- 先手动降幂（比如设 `x=m^2`）
- 只留最关键的 2~3 个方程

------

### ❌ 显示 `no univariate poly found`

👉 说明当前顺序没消出来
 👉 你可以：

- 增加一个方程
- 检查方程是否真的相关
- 手动指定顺序（固定 vars_all）

------

## 九、一句话总结（你可以记住这个）

> **这个脚本 = GB 消元自动化工具**
>
> - 能用就用
> - 能消到线性就稳赢
> - 解不出来通常不是你代码错，是题目结构不适合 GB